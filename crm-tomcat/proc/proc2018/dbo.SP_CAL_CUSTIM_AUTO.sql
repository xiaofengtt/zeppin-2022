USE EFCRM
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE SP_CAL_CUSTIM_AUTO
WITH ENCRYPTION
AS
    DECLARE @V_CUST_ID INT,@V_CUST_NAME NVARCHAR(200),@V_MAX_RULE_ID INT,@V_USER_ID INT
    DECLARE @V_RG_MONEY NUMERIC(15,0),@V_RG_TIMES INT,@V_MULTIPLE NUMERIC(10,3),@V_IM_VALUE INT,@OLD_IM_VALUE INT,@V_CUST_LEVEL_ID INT
    DECLARE @IBUSI_FLAG INT,@SBUSI_NAME NVARCHAR(40),@SSUMMARY NVARCHAR(200)
    
    SELECT @IBUSI_FLAG = 20701
    SELECT @V_USER_ID=USER_ID FROM TSYSTEMINFO
    SELECT @V_MAX_RULE_ID=MAX(RULE_ID) FROM IM_RULE_AMOUNT
    
    BEGIN TRY
    CREATE TABLE #TMP_REC(SERIAL INT) --记录处理临时表
    --待计算的客户临时表
	CREATE TABLE #TMP_AUTO_CustomerIM(
		CUST_ID         INTEGER, --客户ID
		RG_TIMES        INTEGER, --认购次数
	)
	--客户购买金额表，包括受让部分
	CREATE TABLE #TMP_CUST_RG(
		SERIAL          INTEGER IDENTITY(1,1), --序号，也是购买顺序的依据
		CUST_ID         INTEGER, --客户ID
		RG_MONEY        NUMERIC(15,0), --购买金额
		CHECK_TIME      DATETIME, --交易审核时间
	)
	--认购部分
	INSERT INTO #TMP_AUTO_CustomerIM(CUST_ID,RG_TIMES)
		SELECT CUST_ID,COUNT(RG_MONEY) RG_TIMES FROM INTRUST..TCONTRACT 
			WHERE CHECK_FLAG=2 
				AND RG_MONEY>=10000
				AND (CHECK_TIME>GETDATE()-1 OR NOT EXISTS (SELECT * FROM IM_CUST_INTEGRAL_CARD WHERE CUST_ID=INTRUST..TCONTRACT.CUST_ID))
			GROUP BY CUST_ID
	--受让部分
	SELECT TO_CUST_ID,COUNT(TO_MONEY) RG_TIMES INTO #TMP_BENCHG FROM INTRUST..TBENCHANGES
			WHERE CHECK_FLAG=2 
				AND TO_MONEY>=10000
				AND (CHECK_TIME>GETDATE()-1 OR NOT EXISTS (SELECT * FROM IM_CUST_INTEGRAL_CARD WHERE CUST_ID=INTRUST..TBENCHANGES.TO_CUST_ID))
			GROUP BY TO_CUST_ID
	UPDATE #TMP_AUTO_CustomerIM SET RG_TIMES=A.RG_TIMES+ISNULL(B.RG_TIMES,0)
		FROM #TMP_AUTO_CustomerIM A LEFT JOIN #TMP_BENCHG B ON A.CUST_ID=B.TO_CUST_ID
    INSERT INTO #TMP_AUTO_CustomerIM(CUST_ID,RG_TIMES)
		SELECT TO_CUST_ID,RG_TIMES FROM #TMP_BENCHG WHERE NOT EXISTS (SELECT * FROM #TMP_AUTO_CustomerIM WHERE CUST_ID=#TMP_BENCHG.TO_CUST_ID)
    --受让部分计算时，加上认购部分的认购次数
	DECLARE CURS_1 CURSOR FOR SELECT CUST_ID,RG_TIMES FROM #TMP_AUTO_CustomerIM ORDER BY CUST_ID
    OPEN CURS_1
    FETCH NEXT FROM CURS_1 INTO @V_CUST_ID,@V_RG_TIMES
    WHILE @@FETCH_STATUS=0
    BEGIN
		SELECT @V_CUST_NAME=CUST_NAME FROM TCustomers WHERE CUST_ID=@V_CUST_ID
		TRUNCATE TABLE #TMP_REC
		--取客户的所有购买记录
		TRUNCATE TABLE #TMP_CUST_RG
		INSERT INTO #TMP_CUST_RG(CUST_ID,RG_MONEY,CHECK_TIME)
			SELECT CUST_ID,CAST(ISNULL(RG_MONEY,0) AS NUMERIC(15,0)),CHECK_TIME FROM INTRUST..TCONTRACT WHERE CUST_ID=@V_CUST_ID AND CHECK_FLAG=2-- ORDER BY CHECK_TIME
			UNION 
			SELECT TO_CUST_ID,CAST(ISNULL(TO_MONEY,0) AS NUMERIC(15,0)),CHECK_TIME FROM INTRUST..TBENCHANGES WHERE TO_CUST_ID=@V_CUST_ID AND CHECK_FLAG=2
			ORDER BY CHECK_TIME
		--取最后一条购买记录计算积分
		SELECT TOP 1 @V_RG_MONEY=RG_MONEY FROM #TMP_CUST_RG ORDER BY SERIAL DESC
		IF @V_RG_TIMES>@V_MAX_RULE_ID SET @V_RG_TIMES=@V_MAX_RULE_ID
		SELECT @V_MULTIPLE=MULTIPLE FROM IM_RULE_AMOUNT WHERE RULE_ID=@V_RG_TIMES AND @V_RG_MONEY>=LOWER_VALUE AND (@V_RG_MONEY<UPPER_VALUE OR UPPER_VALUE=0)
		SET @V_MULTIPLE= ISNULL(@V_MULTIPLE,1)
		SET @V_IM_VALUE=ISNULL(FLOOR(@V_RG_MONEY/10000),0)*@V_MULTIPLE --计算当前积分
		--通过积分，计算客户的积分等级
		SELECT @OLD_IM_VALUE=RULE_INTEGAL FROM IM_CUST_INTEGRAL_CARD WHERE CUST_ID=@V_CUST_ID
		SET @OLD_IM_VALUE=ISNULL(@OLD_IM_VALUE,0)
		SELECT @V_CUST_LEVEL_ID=CUST_LEVEL_ID FROM IM_CUST_LEVEL WHERE @OLD_IM_VALUE+@V_IM_VALUE>=LOWER_VALUE AND (@OLD_IM_VALUE+@V_IM_VALUE<UPPER_VALUE OR UPPER_VALUE=0)
		--SELECT * FROM IM_CUST_LEVEL
		--SELECT * FROM IM_CUST_INTEGRAL_CARD
		UPDATE IM_CUST_INTEGRAL_CARD SET RULE_INTEGAL=RULE_INTEGAL+@V_IM_VALUE,CUST_LEVEL_ID=@V_CUST_LEVEL_ID WHERE CUST_ID=@V_CUST_ID
		IF @@ROWCOUNT=0
		BEGIN
			--如果认购次数大于规则中的首次，重新计算历史积分
			IF @V_RG_TIMES>=2
			BEGIN --计算所有的历史积分
				SET @V_IM_VALUE=0
				DECLARE @CURR_TIMES INT,@V_SERIAL INT
							
				SET @CURR_TIMES=1
				WHILE @CURR_TIMES<=@V_RG_TIMES
				BEGIN
					IF @CURR_TIMES>=@V_MAX_RULE_ID
					BEGIN --达到规则的最后
						SET @V_RG_TIMES=@V_MAX_RULE_ID
						SET @CURR_TIMES=@V_RG_TIMES
						--找出没有计算过积分的合同记录
						SELECT @V_RG_MONEY=SUM(RG_MONEY) FROM #TMP_CUST_RG A WHERE CUST_ID=@V_CUST_ID AND NOT EXISTS (SELECT * FROM #TMP_REC WHERE SERIAL=A.SERIAL)
						SELECT @V_MULTIPLE=MULTIPLE FROM IM_RULE_AMOUNT WHERE RULE_ID=@CURR_TIMES AND @V_RG_MONEY>=LOWER_VALUE AND (@V_RG_MONEY<UPPER_VALUE OR UPPER_VALUE=0)
					END
					ELSE
					BEGIN
						--找出没有计算过积分的合同记录
						SELECT TOP 1 @V_RG_MONEY=RG_MONEY,@V_SERIAL=SERIAL FROM #TMP_CUST_RG A WHERE CUST_ID=@V_CUST_ID AND NOT EXISTS (SELECT * FROM #TMP_REC WHERE SERIAL=A.SERIAL) ORDER BY SERIAL
						SELECT @V_MULTIPLE=MULTIPLE FROM IM_RULE_AMOUNT WHERE RULE_ID=@CURR_TIMES AND @V_RG_MONEY>=LOWER_VALUE AND (@V_RG_MONEY<UPPER_VALUE OR UPPER_VALUE=0)
						INSERT INTO #TMP_REC(SERIAL) VALUES(@V_SERIAL)
						
					END
					SET @V_MULTIPLE= ISNULL(@V_MULTIPLE,1)
					SET @V_IM_VALUE=@V_IM_VALUE+ISNULL(FLOOR(@V_RG_MONEY/10000),0)*@V_MULTIPLE --计算当前积分
					SET @CURR_TIMES=@CURR_TIMES+1
				END
				--通过积分，计算客户的积分等级
				SELECT @V_CUST_LEVEL_ID=CUST_LEVEL_ID FROM IM_CUST_LEVEL WHERE @V_IM_VALUE>=LOWER_VALUE AND (@V_IM_VALUE<UPPER_VALUE OR UPPER_VALUE=0)
			END	
			INSERT INTO IM_CUST_INTEGRAL_CARD(CUST_ID,CUST_NAME,CUST_LEVEL_ID,BASE_INTEGRAL,RULE_INTEGAL,TOTAL_INTEGAL,EXCHANGED_INTEGAL)
				SELECT @V_CUST_ID,@V_CUST_NAME,@V_CUST_LEVEL_ID,0,@V_IM_VALUE,@V_IM_VALUE,0
		END
		
		FETCH NEXT FROM CURS_1 INTO @V_CUST_ID,@V_RG_TIMES
    END
    CLOSE CURS_1
    DEALLOCATE CURS_1
    
    END TRY

    --异常处理
    BEGIN CATCH
        IF EXISTS(SELECT * FROM MASTER.dbo.syscursors where cursor_name='CURS_1')
        BEGIN
			CLOSE CURS_1
			DEALLOCATE CURS_1
        END
        DECLARE @V_ERROR_STR NVARCHAR(1000),@V_ERROR_NUMBER INT,@V_ERROR_SEVERITY INT,@V_ERROR_STATE INT,
                @V_ERROR_PROCEDURE sysname,@V_ERROR_LINE INT,@V_ERROR_MESSAGE NVARCHAR(4000)

        SELECT @V_ERROR_STR = N'%s<br>Procedure:%s,Line:%d',
               @V_ERROR_NUMBER = ERROR_NUMBER(),
               @V_ERROR_SEVERITY = ERROR_SEVERITY(),
               @V_ERROR_STATE = ERROR_STATE(),
               @V_ERROR_PROCEDURE = ERROR_PROCEDURE(),
               @V_ERROR_LINE = ERROR_LINE(),
               @V_ERROR_MESSAGE = ERROR_MESSAGE()

        RAISERROR(@V_ERROR_STR,@V_ERROR_SEVERITY,1,@V_ERROR_MESSAGE,@V_ERROR_PROCEDURE,@V_ERROR_LINE)
    END CATCH
GO
