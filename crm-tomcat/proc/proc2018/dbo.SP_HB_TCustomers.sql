USE EFCRM
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE SP_HB_TCustomers @IN_FROM_CUST_ID INT,
                                  @IN_TO_CUST_ID   INT,
                                  @IN_INPUT_MAN    INT,
                                  @IN_HB_RGMEONY   INT = 1 --1时合并认购次数，金额，存量金额等字段值
WITH ENCRYPTION
AS
    SET NOCOUNT ON
    SET XACT_ABORT ON

    DECLARE @V_BOOK_CODE INT, @V_INTRUST_OPERATOR INT
    DECLARE @RET INT, @V_DT_INTRUST INT
    SELECT @V_DT_INTRUST = VALUE FROM TSYSCONTROL WHERE FLAG_TYPE = N'DT_INTRUST'
    DECLARE @V_RET_CODE INT, @IBUSI_FLAG INT
    DECLARE @SBUSI_NAME NVARCHAR(40), @SSUMMARY NVARCHAR(200)
    SELECT  @V_RET_CODE = -20602000, @IBUSI_FLAG = 20602
    SELECT  @SBUSI_NAME = N'合并客户资料', @SSUMMARY = N'合并客户资料'

    IF NOT EXISTS(SELECT * FROM TCustomers WHERE CUST_ID = @IN_FROM_CUST_ID)
        RETURN @V_RET_CODE - 1  --客户编号1不存在
    IF NOT EXISTS(SELECT * FROM TCustomers WHERE CUST_ID = @IN_TO_CUST_ID)
       RETURN @V_RET_CODE - 2  --客户编号2不存在

    IF @V_DT_INTRUST = 1 --启用分布式
    BEGIN
        SELECT @V_BOOK_CODE = INTRUST_BOOKCODE, @V_INTRUST_OPERATOR = INTRUST_Operator
            FROM SRV_Intrust.INTRUST.dbo.TOperatorMap WHERE CRM_Operator = @IN_INPUT_MAN
        IF @V_BOOK_CODE IS NULL --从sso映射表中未取到Intrust帐套时，使用Intrust操作员表设置的默认帐套
            SELECT @V_BOOK_CODE = BOOK_CODE FROM SRV_Intrust.INTRUST.dbo.TOPERATOR WHERE OP_CODE = @V_INTRUST_OPERATOR
        BEGIN DISTRIBUTED TRANSACTION
    END
    ELSE --无分布式或本地信托数据库
    BEGIN TRANSACTION
    IF @V_INTRUST_OPERATOR IS NULL --从sso映射表中未取到Intrust操作员时，使用CRM操作员
        SELECT @V_INTRUST_OPERATOR = @IN_INPUT_MAN
    IF @V_BOOK_CODE IS NULL --最后取不到使用默认值1
        SELECT @V_BOOK_CODE = 1

    UPDATE TCustomerChanges SET CUST_ID = @IN_TO_CUST_ID  WHERE CUST_ID = @IN_FROM_CUST_ID
    IF @@ERROR <> 0
    BEGIN
        ROLLBACK TRANSACTION
        RETURN -107
    END
    IF @@ERROR <> 0
    BEGIN
        ROLLBACK TRANSACTION
        RETURN -107
    END
	--客户预约记录合并
	UPDATE TPRECONTRACT
        SET CUST_ID = @IN_TO_CUST_ID
        WHERE CUST_ID = @IN_FROM_CUST_ID
    --操作记录
    INSERT INTO TCustomerChanges(CUST_ID,FIELD_NAME,FIELD_CN_NAME,OLD_FIELD_INFO,NEW_FIELD_INFO,INPUT_MAN)
        SELECT CUST_ID,N'FROM_CUST_ID',N'客户合并',CONVERT(CHAR,CUST_ID),CONVERT(CHAR,@IN_TO_CUST_ID),@IN_INPUT_MAN
        FROM TCustomers WHERE CUST_ID = @IN_FROM_CUST_ID
    INSERT INTO TCustomerChanges(CUST_ID,FIELD_NAME,FIELD_CN_NAME,OLD_FIELD_INFO,NEW_FIELD_INFO,INPUT_MAN)
        SELECT CUST_ID,N'TO_CUST_ID',N'客户合并',CONVERT(CHAR,@IN_FROM_CUST_ID),CONVERT(CHAR,CUST_ID),@IN_INPUT_MAN
        FROM TCustomers WHERE CUST_ID = @IN_TO_CUST_ID
    --
    UPDATE TCustomers
        SET STATUS = N'112805',
            STATUS_NAME = N'删除',
            RG_TIMES = 0,
            TOTAL_MONEY = 0,
            CURRENT_MONEY = 0
        WHERE CUST_ID = @IN_FROM_CUST_ID
    IF @@ERROR <> 0
    BEGIN
        ROLLBACK TRANSACTION
        RETURN -108
    END
    -------------------------------
    IF @V_DT_INTRUST = 1 --启用分布式
    BEGIN
        IF NOT EXISTS(SELECT 1 FROM SRV_Intrust.INTRUST.dbo.TCUSTOMERINFO WHERE CUST_ID = @IN_TO_CUST_ID)
        BEGIN
            ROLLBACK TRANSACTION
            RETURN -100 --目标客户在信托库中不存在，不能做合并
        END
        IF EXISTS(SELECT 1 FROM SRV_Intrust.INTRUST.dbo.TCUSTOMERINFO WHERE CUST_ID = @IN_FROM_CUST_ID)
        BEGIN --源客户在信托库中不存在，跳过合并信托数据
            exec @RET = srv_intrust.INTRUST.dbo.SP_HB_TCUSTOMERINFO @IN_FROM_CUST_ID, @IN_TO_CUST_ID, @V_INTRUST_OPERATOR, @IN_HB_RGMEONY
            IF @@ERROR <> 0 OR @RET < 0
            BEGIN
                ROLLBACK TRANSACTION
                RETURN -100
            END
            UPDATE TCustomers SET RG_TIMES = B.RG_TIMES, TOTAL_MONEY = B.TOTAL_MONEY, CURRENT_MONEY = B.CURRENT_MONEY, LAST_RG_DATE = B.LAST_RG_DATE
                FROM TCustomers A, SRV_Intrust.INTRUST.dbo.TCUSTOMERINFO B WHERE A.CUST_ID = B.CUST_ID AND A.CUST_ID = @IN_TO_CUST_ID
            IF @@ERROR <> 0
            BEGIN
                ROLLBACK TRANSACTION
                RETURN -108
            END
        END
    END
    ELSE IF (@V_DT_INTRUST = 2) AND EXISTS(SELECT * FROM master..sysdatabases WHERE NAME = N'INTRUST') --本地信托数据库
    BEGIN
        IF NOT EXISTS(SELECT 1 FROM INTRUST.dbo.TCUSTOMERINFO WHERE CUST_ID = @IN_TO_CUST_ID)
        BEGIN
            ROLLBACK TRANSACTION
            RETURN -100 --目标客户在信托库中不存在，不能做合并
        END
        IF EXISTS(SELECT 1 FROM INTRUST.dbo.TCUSTOMERINFO WHERE CUST_ID = @IN_FROM_CUST_ID)
        BEGIN --源客户在信托库中不存在，跳过合并信托数据
            exec @RET = INTRUST.dbo.SP_HB_TCUSTOMERINFO @IN_FROM_CUST_ID, @IN_TO_CUST_ID, @V_INTRUST_OPERATOR, @IN_HB_RGMEONY
            IF @@ERROR <> 0 OR @RET < 0
            BEGIN
               ROLLBACK TRANSACTION
               RETURN -100
            END
            UPDATE TCustomers SET RG_TIMES = B.RG_TIMES, TOTAL_MONEY = B.TOTAL_MONEY, CURRENT_MONEY = B.CURRENT_MONEY, LAST_RG_DATE = B.LAST_RG_DATE
                FROM TCustomers A, INTRUST..TCUSTOMERINFO B WHERE A.CUST_ID = B.CUST_ID AND A.CUST_ID = @IN_TO_CUST_ID
            IF @@ERROR <> 0
            BEGIN
                ROLLBACK TRANSACTION
                RETURN -108
            END
        END
    END

    SELECT @SSUMMARY = N'合并客户资料：从cust_id:=' + CONVERT(NVARCHAR(10),@IN_FROM_CUST_ID) + N',到cust_id:=' + CONVERT(NVARCHAR(10),@IN_TO_CUST_ID)
    INSERT INTO TLOGLIST(BUSI_FLAG,BUSI_NAME,OP_CODE,SUMMARY)
        VALUES(@IBUSI_FLAG,@SBUSI_NAME,@IN_INPUT_MAN,@SSUMMARY)
    IF @@ERROR <> 0
    BEGIN
        ROLLBACK TRANSACTION
        RETURN -109
    END

    COMMIT TRANSACTION
    SET XACT_ABORT OFF
    RETURN 100
GO
