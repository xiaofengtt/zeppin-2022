USE EFCRM
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE SP_MODI_PRODUCT_SERVICEMAN @IN_PRODUCT_ID  INT,
                                            @IN_SERVICE_MAN INT,
                                            @IN_INPUT_MAN   INT
WITH ENCRYPTION
AS
    SET NOCOUNT ON
    DECLARE @V_RET_CODE INT, @IBUSI_FLAG INT, @SBUSI_NAME NVARCHAR(40), @SSUMMARY NVARCHAR(200)
    SELECT @V_RET_CODE = -30101000, @IBUSI_FLAG = 30101
    SELECT @SBUSI_NAME = N'修改产品客户经理', @SSUMMARY = N'修改产品客户经理'

    DECLARE @V_DT_INTRUST INT
    SELECT @V_DT_INTRUST = VALUE FROM TSYSCONTROL WHERE FLAG_TYPE = N'DT_INTRUST'

    IF @V_DT_INTRUST = 1 --启用分布式
    BEGIN
        BEGIN DISTRIBUTED TRANSACTION
    END
    ELSE --无分布式或本地信托数据库
        BEGIN TRANSACTION

    IF @V_DT_INTRUST = 1 --启用分布式
        UPDATE SRV_Intrust.INTRUST.dbo.TPRODUCT SET SERVICE_MAN = @IN_SERVICE_MAN WHERE PRODUCT_ID = @IN_PRODUCT_ID
    ELSE IF (@V_DT_INTRUST = 2) AND EXISTS(SELECT * FROM master..sysdatabases WHERE NAME = N'INTRUST') --本地信托数据库
        UPDATE INTRUST..TPRODUCT SET SERVICE_MAN = @IN_SERVICE_MAN WHERE PRODUCT_ID = @IN_PRODUCT_ID
    IF @@ERROR <> 0
    BEGIN
        ROLLBACK TRANSACTION
        RETURN -100
    END

    SELECT @SSUMMARY = N'修改产品客户经理'
    INSERT INTO TLOGLIST(BUSI_FLAG,BUSI_NAME,OP_CODE,SUMMARY)
        VALUES(@IBUSI_FLAG,@SBUSI_NAME,@IN_INPUT_MAN,@SSUMMARY)
    IF @@ERROR <> 0
    BEGIN
        ROLLBACK TRANSACTION
        RETURN -100
    END

    COMMIT TRANSACTION
    RETURN 100
GO
